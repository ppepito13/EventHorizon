
/**
 * @fileOverview Slate JSON to React Component Renderer.
 * 
 * This component is responsible for safely rendering the structured JSON content
 * generated by the Admin's Rich Text Editor into styled Tailwind/Shadcn components.
 */

import React from 'react';
import { Descendant, Text as SlateText } from 'slate';
import { CustomElement } from '@/lib/slate-types';

/**
 * Recursive node renderer.
 * Maps individual Slate nodes (Text or Elements) to HTML/JSX tags.
 */
const Node = ({ node }: { node: Descendant }): JSX.Element => {
    // Handling Leaf nodes (inline text with formatting)
    if (SlateText.isText(node)) {
        let leaf: JSX.Element | string = node.text;

        if (node.bold) {
            leaf = <strong>{leaf}</strong>;
        }
        if (node.italic) {
            leaf = <em>{leaf}</em>;
        }
        if (node.underline) {
            leaf = <u>{leaf}</u>;
        }
        if (node.code) {
            leaf = <code className="bg-muted text-foreground font-mono text-sm px-1 py-0.5 rounded-sm">{leaf}</code>;
        }
        return <>{leaf}</>;
    }

    // Handling Block elements
    const element = node as CustomElement;
    const children = element.children.map((n, i) => <Node key={i} node={n} />);

    const style: React.CSSProperties = { 
        textAlign: element.align,
        // We use 1.5em padding for each indentation level defined in the editor.
        paddingLeft: element.indent && element.type !== 'list-item' ? `${element.indent * 1.5}em` : undefined,
        listStylePosition: 'inside' 
    };

    switch (element.type) {
        case 'heading-one':
            return <h1 style={style} className="text-3xl font-bold mb-4">{children}</h1>;
        case 'heading-two':
            return <h2 style={style} className="text-2xl font-semibold mb-3">{children}</h2>;
        case 'block-quote':
            return <blockquote style={style} className="border-l-4 border-primary pl-4 italic my-4">{children}</blockquote>;
        
        case 'numbered-list':
            return <ol style={style} className="list-decimal my-4">{children}</ol>;
        case 'bulleted-list':
            return <ul style={style} className="list-disc my-4">{children}</ul>;
        case 'list-item':
            const liStyle: React.CSSProperties = {
                paddingLeft: element.indent ? `${element.indent * 1.5}em` : undefined,
                textAlign: element.align,
                listStylePosition: 'inside'
            };
            return <li style={liStyle} className="mb-1">{children}</li>;

        case 'image':
            const imgContainerStyle: React.CSSProperties = {
                paddingLeft: element.indent ? `${element.indent * 1.5}em` : undefined,
                textAlign: element.align || 'left',
            };
            const imgStyle = {
                display: 'inline-block',
                width: element.width,
                height: element.height,
                maxWidth: '100%',
                maxHeight: '100%',
            };
            return (
                <div style={imgContainerStyle}>
                    <img src={element.url} alt="" style={imgStyle} className="my-4 rounded-md shadow-md" />
                </div>
            );
        case 'paragraph':
        default:
            return <p style={style} className="mb-4 last:mb-0 leading-relaxed">{children}</p>;
    }
};

interface RichTextRendererProps {
    content: string;
}

/**
 * Main entry point for rendering Slate.js content strings.
 * 
 * @param {string} content - A JSON string representing the editor state.
 */
export const RichTextRenderer: React.FC<RichTextRendererProps> = ({ content }) => {
    if (!content) {
        return null;
    }

    let parsedContent: Descendant[];

    try {
        parsedContent = JSON.parse(content);
    } catch (e) {
        // Fallback: If content isn't valid JSON, treat it as raw text.
        // This handles legacy data or simple text descriptions.
        return <p className="whitespace-pre-wrap">{content}</p>;
    }

    if (!Array.isArray(parsedContent)) {
        return <p className="whitespace-pre-wrap">{content}</p>;
    }

    return (
        <div className="prose dark:prose-invert max-w-none">
            {parsedContent.map((node, i) => (
                <Node key={i} node={node} />
            ))}
        </div>
    );
};
