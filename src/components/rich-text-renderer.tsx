// This component is responsible for safely rendering the JSON content
// generated by the Slate.js editor into styled React components.

import React, { Fragment } from 'react';
import { Descendant, Text as SlateText } from 'slate';

interface RichTextRendererProps {
  content?: string;
}

// Default component for unknown element types
const DefaultElement: React.FC<any> = ({ attributes, children }) => {
    return <p {...attributes}>{children}</p>;
};

// Component to render a single Slate node
const Node = ({ node }: { node: Descendant }): JSX.Element => {
    if (SlateText.isText(node)) {
        let leaf: JSX.Element | string = node.text;

        if (node.bold) {
            leaf = <strong>{leaf}</strong>;
        }
        if (node.italic) {
            leaf = <em>{leaf}</em>;
        }
        if (node.underline) {
            leaf = <u>{leaf}</u>;
        }
        if (node.code) {
            leaf = <code>{leaf}</code>;
        }
        return <>{leaf}</>;
    }

    const children = node.children.map((n, i) => <Node key={i} node={n} />);

    switch (node.type) {
        case 'heading-one':
            return <h1>{children}</h1>;
        case 'heading-two':
            return <h2>{children}</h2>;
        case 'block-quote':
            return <blockquote>{children}</blockquote>;
        case 'numbered-list':
            return <ol>{children}</ol>;
        case 'bulleted-list':
            return <ul>{children}</ul>;
        case 'list-item':
            return <li>{children}</li>;
        case 'paragraph':
            return <p>{children}</p>;
        default:
            return <DefaultElement>{children}</DefaultElement>;
    }
};

export const RichTextRenderer: React.FC<RichTextRendererProps> = ({ content }) => {
    if (!content) {
        return null;
    }

    let parsedContent: Descendant[];

    try {
        parsedContent = JSON.parse(content);
    } catch (e) {
        // If it's not valid JSON, treat it as plain text in a paragraph.
        return <p>{content}</p>;
    }

    if (!Array.isArray(parsedContent)) {
        return <p>{content}</p>; // Fallback for invalid structure
    }

    return (
        <div className="prose dark:prose-invert max-w-none">
            {parsedContent.map((node, i) => (
                <Node key={i} node={node} />
            ))}
        </div>
    );
};
